% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sheets_speedread.R
\name{sheets_speedread}
\alias{sheets_speedread}
\title{Read Sheet as csv}
\usage{
sheets_speedread(ss, sheet = NULL, range = NULL, skip = 0, ...)
}
\arguments{
\item{ss}{Something that identifies a Google Sheet: its file ID, a URL from
which we can recover the ID, an instance of \code{googlesheets4_spreadsheet}
(returned by \code{\link[=sheets_get]{sheets_get()}}, or a \code{\link[googledrive:dribble]{dribble}}, which
is how googledrive represents Drive files. Processed through
\code{\link[=as_sheets_id]{as_sheets_id()}}.}

\item{sheet}{Sheet to read, in the sense of "worksheet" or "tab". You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via \code{range}. If neither argument specifies the sheet, defaults to the first visible sheet.}

\item{range}{A cell range to read from. If \code{NULL}, all non-empty cells are
read. Otherwise specify \code{range} as described in \href{https://developers.google.com/sheets/api/guides/concepts#a1_notation}{Sheets A1 notation}
or using the helpers documented in \link{cell-specification}. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: \code{"Sheet1!A1:B2"}, \code{"Sheet1!A:A"},
\code{"Sheet1!1:2"}, \code{"Sheet1!A5:A"}, \code{"A1:B2"}, \code{"Sheet1"}. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over \code{skip}, \code{n_max} and
\code{sheet}. Note \code{range} can be a named range, like \code{"sales_data"}, without
any cell reference.}

\item{skip}{Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if \code{range} is given.}

\item{...}{Passed along to \code{vroom::vroom()}.}
}
\value{

}
\description{
The \code{export} URL supports various query parameters. We exploit \code{format=csv}
and, optionally, \code{gid=SHEET_ID} and/or \code{range=A2:D5} (\code{range} must really be
cell range in this case, not a sheet name or named range):\preformatted{# here is the base URL:
https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/export

# examples of the query part
?format=csv
?format=csv?range=A1_range
?format=csv?gid=SHEET_ID
?format=csv?range=A1_range?gid=SHEET_ID
}

Handy gist of various query parameters that work for the \code{export} URL, with
special attention to the PDF format:
\itemize{
\item \url{https://gist.github.com/Spencer-Easton/78f9867a691e549c9c70}
}

The "Chart Tools datasource protocol" is another way to access values in
Sheets, designed to make Sheets play nicely with the Google Charts API. We
can use the datasource URL as another way to get data as CSV (or JSON, etc.).
It is more powerful than the \code{export} URL.

Stack Overflow answer that links to various pages re: the "Chart Tools
datasource protocol"
\itemize{
\item \url{https://stackoverflow.com/a/33727897/2825349}
}

The most important link is about "Query Source Ranges":
\itemize{
\item \url{https://developers.google.com/chart/interactive/docs/spreadsheets#queryurlformat}
}

Examples of such URLs\preformatted{# here is the base URL:
https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/gviz/tq

# examples of the query part
?tqx=out:csv&sheet=\{sheet_name\}
?range=A1:C4
?headers=N
?gid=N
}

A readr issue that demonstrates sending an Authorization header
\itemize{
\item \url{https://github.com/tidyverse/readr/issues/935}
}
}
\examples{
# exploring the export URL
base_url_template <- "https://docs.google.com/spreadsheets/d/{spreadsheet_id}/export"

(spreadsheet_id <- unclass(sheets_example("deaths")))
(deaths_url <- glue::glue(base_url_template))
meta <- sheets_get(spreadsheet_id)
other_sheet_id <- vlookup("other", meta$sheets, "name", "id")
deaths_range <- "A5:F15"

# send no extras
query <- list(format = "csv")
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)

# send an A1 cell range (reads first sheet)
query <- list(format = "csv", range = deaths_range)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)

# send gid of a worksheet
query <- list(format = "csv", gid = other_sheet_id)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)

# send cell range and gid of a worksheet
query <- list(format = "csv", gid = other_sheet_id, range = deaths_range)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)

# can you send a (work)sheet name via range?
query <- list(format = "csv", range = "other")
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
# Error in open.connection(con, "rb") : HTTP error 400.
# NO THIS DOES NOT WORK

# can you send a named range via range?
query <- list(format = "csv", range = "other_data")
url <- httr::modify_url(deaths_url, query = query)
readr::read_csv(url)
# Error in open.connection(con, "rb") : HTTP error 400.
# NO THIS DOES NOT WORK

# exploring access via the Chart Tools datasource protocol
base_url_template <- "https://docs.google.com/spreadsheets/d/{spreadsheet_id}/gviz/tq"

(spreadsheet_id <- unclass(sheets_example("deaths")))
(deaths_url <- glue::glue(base_url_template))
meta <- sheets_get(spreadsheet_id)
other_sheet_id <- vlookup("other", meta$sheets, "name", "id")
deaths_range <- "A5:F15"

# send no extras
query <- list(tqx = "out:csv")
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)
# very interesting treatment of the header and footer rows!

# send a sheet id
query <- list(tqx = "out:csv", gid = other_sheet_id)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)

# specify headers rows
query <- list(tqx = "out:csv", headers = 5)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)
# seems to be same result as letting it discover header rows

# send cell range
query <- list(tqx = "out:csv", range = deaths_range)
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)
# WORKS

# send named range
query <- list(tqx = "out:csv", range = "arts_data")
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)
# DOES NOT SEEM TO WORK

# send sheet name
query <- list(tqx = "out:csv", sheet = "other")
(url <- httr::modify_url(deaths_url, query = query))
readr::read_csv(url)
vroom::vroom(url)
# WORKS (other than header/footer weirdness)

# quick speed test with Sheet from
# https://github.com/tidyverse/googlesheets4/issues/122
(spreadsheet_id <- "1mnWcn7bd7obaXd05rnXrEtgzMBLdy7ctsYvlQM52W00")

export_url_template <- "https://docs.google.com/spreadsheets/d/{spreadsheet_id}/export"
(nba_export_url <- glue::glue(export_url_template))
query <- list(format = "csv")
(nba_export_url <- httr::modify_url(nba_export_url, query = query))
readr::read_csv(nba_export_url) # 56,765 x 23
vroom::vroom(nba_export_url)    # 56,765 x 23

datasource_url_template <- "https://docs.google.com/spreadsheets/d/{spreadsheet_id}/gviz/tq"
(nba_datasource_url <- glue::glue(datasource_url_template))
query <- list(tqx = "out:csv")
(nba_datasource_url <- httr::modify_url(nba_datasource_url, query = query))
readr::read_csv(nba_datasource_url) # 56,765 x 23
vroom::vroom(nba_datasource_url)    # 56,765 x 23

library(bench)
bnch <- bench::mark(
  readr::read_csv(nba_export_url),
  vroom::vroom(nba_export_url),
  readr::read_csv(nba_datasource_url),
  vroom::vroom(nba_datasource_url),
  iterations = 1,
  check = FALSE
)
bnch
}

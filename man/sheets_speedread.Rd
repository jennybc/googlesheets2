% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sheets_speedread.R
\name{sheets_speedread}
\alias{sheets_speedread}
\title{Read Sheet as CSV}
\usage{
sheets_speedread(
  ss,
  sheet = NULL,
  range = NULL,
  skip = 0,
  ...,
  .url = c("export", "datasource"),
  .method = c("vroom", "readr")
)
}
\arguments{
\item{ss}{Something that identifies a Google Sheet: its file ID, a URL from
which we can recover the ID, an instance of \code{googlesheets4_spreadsheet}
(returned by \code{\link[=sheets_get]{sheets_get()}}, or a \code{\link[googledrive:dribble]{dribble}}, which
is how googledrive represents Drive files. Processed through
\code{\link[=as_sheets_id]{as_sheets_id()}}.}

\item{sheet}{Sheet to read, in the sense of "worksheet" or "tab". You can identify a sheet by name, with a string, or by position, with a number. Ignored if the sheet is specified via \code{range}. If neither argument specifies the sheet, defaults to the first visible sheet.}

\item{range}{A cell range to read from. If \code{NULL}, all non-empty cells are
read. Otherwise specify \code{range} as described in \href{https://developers.google.com/sheets/api/guides/concepts#a1_notation}{Sheets A1 notation}
or using the helpers documented in \link{cell-specification}. Sheets uses
fairly standard spreadsheet range notation, although a bit different from
Excel. Examples of valid ranges: \code{"Sheet1!A1:B2"}, \code{"Sheet1!A:A"},
\code{"Sheet1!1:2"}, \code{"Sheet1!A5:A"}, \code{"A1:B2"}, \code{"Sheet1"}. Interpreted
strictly, even if the range forces the inclusion of leading, trailing, or
embedded empty rows or columns. Takes precedence over \code{skip}, \code{n_max} and
\code{sheet}. Note \code{range} can be a named range, like \code{"sales_data"}, without
any cell reference.}

\item{skip}{Minimum number of rows to skip before reading anything, be it
column names or data. Leading empty rows are automatically skipped, so this
is a lower bound. Ignored if \code{range} is given.}

\item{...}{Passed along to \code{vroom::vroom()} or \code{readr::read_csv()}.}

\item{.url}{Whether to use the \code{"export"} (default) or \code{"datasource"} URL.}

\item{.method}{Whether to process the CSV data with \code{vroom::vroom()}
(default) or \code{readr::read_csv()}.}
}
\value{
A \link[tibble:tibble-package]{tibble}
}
\description{
This function uses a quick-and-dirty method to read a Sheet that bypasses the
Sheets API entirely. It can be much faster than \code{\link[=sheets_read]{sheets_read()}} -- noticeably
so for "large" spreadsheets. \code{sheets_speedread()} forms a special URL that
reads Sheet values via CSV, then sends that data through vroom or readr.
Here are the limitations we must accept to get faster reading:
\itemize{
\item Only cell values are available, not formats.
\item We can't target a named range as the \code{range}.
\item We have no access to the data type of a cell, i.e. we don't know that it's
logical, numeric, or datetime. That must be re-discovered based on the
CSV data (or specified by the user).
\item Auth and error handling have to be handled a bit differently internally,
which may lead to behaviour that differs from other functions in
googlesheets4.
}
}
\section{The export URL}{


The export URL supports various query parameters. We always send
\code{format=csv} and, optionally, \code{gid=SHEET_ID} and/or \code{range=A2:D5} (\code{range}
must really be cell range in this case, not a sheet name or named range):\preformatted{# here is the base URL:
https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/export

# examples of the query part
?format=csv
?format=csv?range=CELL_RANGE
?format=csv?gid=SHEET_ID
?format=csv?range=A1_range?gid=SHEET_ID
}

The export URL supports the use of a bearer token in the Authorization
header.

Gist of various query parameters that work for the export URL, with special
emphasis on the PDF format, which doesn't help us:
\itemize{
\item \url{https://gist.github.com/Spencer-Easton/78f9867a691e549c9c70}
}
}

\section{The datasource URL}{


The "Chart Tools datasource protocol" is another way to access values in
Sheets, designed to make Sheets play nicely with the Google Charts API. We
can use the datasource URL as another way to get data as CSV (or JSON,
etc.). It is more powerful than the export URL, in that it supports an
entire SQL-like query language.

The datasource URL does not appear to work with an Authorization header.
Instead, we must send an access token as part of the query.

Stack Overflow answer that links to various pages re: the "Chart Tools
datasource protocol"
\itemize{
\item \url{https://stackoverflow.com/a/33727897/2825349}
}

The most important link is about "Query Source Ranges":
\itemize{
\item \url{https://developers.google.com/chart/interactive/docs/spreadsheets#queryurlformat}
}

Examples of datasource URLs\preformatted{# here is the base URL:
https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/gviz/tq

# examples of the query part
?tqx=out:csv&sheet=\{sheet_name\}
?range=A1:C4
?headers=N
?gid=N
}

A readr issue that demonstrates sending an Authorization header
\itemize{
\item \url{https://github.com/tidyverse/readr/issues/935}
}
}

\examples{
# Using the large NBA sheet from
# https://github.com/tidyverse/googlesheets4/issues/122
spreadsheet_id <- "1mnWcn7bd7obaXd05rnXrEtgzMBLdy7ctsYvlQM52W00"
(ss <- as_sheets_id(spreadsheet_id))

sheets_speedread(ss, .url = "export", .method = "vroom")
sheets_speedread(ss, .url = "export", .method = "readr")
sheets_speedread(ss, .url = "datasource", .method = "vroom")
sheets_speedread(ss, .url = "datasource", .method = "readr")

if (FALSE) {
library(bench)
bnch <- bench::mark(
  sheets_speedread(ss, .url = "export", .method = "vroom"),
  sheets_speedread(ss, .url = "export", .method = "readr"),
  sheets_speedread(ss, .url = "datasource", .method = "vroom"),
  sheets_speedread(ss, .url = "datasource", .method = "readr"),
  iterations = 5,
  check = FALSE
)
bnch
}

# prove that we can send a cell range, sheet, and col spec through ...
(df <- sheets_speedread(
  sheets_example("deaths"),
  sheet = "other",
  range = "A5:F15",
  col_types = vroom::cols(
    Age = vroom::col_integer(),
    `Date of birth` = vroom::col_date("\%m/\%d/\%Y"),
    `Date of death` = vroom::col_date("\%m/\%d/\%Y")
  ),
  .method = "vroom"
))


if (FALSE) {
# write a private Sheet
(ss <- sheets_write(iris))

# read via 'export' URL (sends a bearer token)
sheets_speedread(ss, .url = "export")

# read via 'datasource' URL (access token goes as query param)
sheets_speedread(ss, .url = "datasource")

# clean up
googledrive::drive_trash(ss)
}
}

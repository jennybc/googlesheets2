---
title: "Range specification"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This is article serves mostly as internal documentation of how various representations of cell ranges relate to each other in googlesheets4.

```{r, R.options = list(tidyverse.quiet = TRUE)}
library(tidyverse)
library(googlesheets4)

sheets_deauth()
```

# User-specified range

Several googlesheets4 functions allow the user to specify which cells to read or write. This range specification comes via the `sheet`, `range`, and (possibly) `skip` arguments. Examples of functions with this interface: `sheets_read()`, `sheets_cells()`, and `sheets_edit()`.

  * `range` is the primary and most powerful argument and takes precedence over
    all others. `range` can be:
      - an [A1-style spreadsheet range](https://developers.google.com/sheets/api/guides/concepts#a1_notation),
        with or without a sheet name, such as "A3:D7" or "arts!A5:F15"
      - a (work)sheet name, such as "arts"
      - a named range, such as "arts_data"
      - a `cell_limits` object made with helpers from the cellranger package
  * `sheet` can be used to specify a (work)sheet by name, such as "arts", or
    by position, such as 3
  * `skip` is an optional argument that appears in `sheets_read()` and 
    `sheets_cells()`, to be compatible with functions like `read.table()`,
    `readr::read_delim()`, and `readxl::read_excel()`. *I haven't exposed it in
    `sheets_edit()`, but maybe I should?*
    
(You might think `n_max` should also be mentioned here, but for technical reasons, in general, `n_max` can only be enforced after we've read data. So it's not part of the range ingest problem.)

Loose ends and hangnails:

  * The story around (work)sheet visibility is muddy. But I'm letting that be,
    because I have yet to have a user interaction that had anything to do with
    sheet (in)visibility.
  * The problem of a completely unspecified range. In a very hand-wavy sense,
    "no range" means "all cells" or "all non-empty cells" or "all non-empty cells in the first (visible?) sheet". That is obviously very imprecise, which
    means that I have to think about how to handle "no range" for each
    individual endpoint or function. Sometimes I inject some info (such as the
    first visible worksheet), so we don't retrieve data that we will just throw away. This is all very special case-y right now.

# Range spec

`range_spec` is an internal S3 class that is typically used inside any function that accepts the `(sheet, range, skip)` trio.

We need some sort of intermediate storage, in order to translate between the various ways the user can express their range and the requirements of different Sheets API endpoints (which differ more than you'd expect!). We generally require metadata about the associated Sheet in order to form a `range_spec`, because we potentially need to lookup the (work)`sheet` by position or determine whether a name refers to a named range or a (work)`sheet`.

The main goal of the `as_range_spec()` internal generic is to transform user-supplied `(sheet, range, skip)` information into:

  * `sheet_name`: (Work)sheet name, can be `NULL`.
  * `named_range`: Name of range, can be `NULL`. But if not `NULL`, then this is
    the complete specification of the range, i.e. it cannot be combined with any
    other information.
  * `cell_range` and/or `cell_limits`: Ways to specify a rectangle of cells, can
    be `NULL`. If user specifies `skip`, that is re-expressed as `cell_limits`. At intake, at most one of `cell_range` and `cell_limits` is populated. But internally, we might populate one from the other, as we prepare the range to
    meet the requirements of a specific API endpoint.
  * `shim`: indicates whether the user specified a specific cell rectangle
     (`shim = TRUE`) or we filled in some specifics pragmatically
     (`shim = FALSE`), which is necessary to express some partially open
     rectangles in A1-notation.
  * (`sheets_df` and `nr_df` are retained in a `range_spec`, if they were
    provided to `as_range_spec()`.)
  * Loose end: I wonder if `range_spec` should have a field for (work)sheet id.
  
Here's how various user-specified ranges are stored as a `range_spec`.

```{r include = FALSE}
df <- read_csv('
    "sheet",      "range", "skip"
"<ignored>", "Asia!A1:B2",    "0"
"<ignored>",     "canada",    "0"
"<ignored>",     "Europe",    "3"
     "NULL",      "A1:B2",    "0"
  "Oceania",      "A1:B2",    "0"
        "2",      "A1:B2",    "0"
')

# anticipated inputs to the NULL method for x (= range)
#
# sheet       skip
# --------------------------------------
#             0     This is what "nothing" looks like. Send nothing.
# Sheet1 / 2  0     Send sheet name.
#             >0    Express skip request in cell_limits object and re-dispatch.
# Sheet1 / 2  >0    <same as previous>


escape_brackets <- function(x) {
  #str_replace_all(x, c("<" = "\\\\<", ">" = "\\\\>"))
  str_replace_all(x, c("<" = "&lt;", ">" = "&gt;"))
}
formatize <- function(x) paste(escape_brackets(format(x)), collapse = "<br>")
```

```{r include = FALSE}
ss <- sheets_example("gapminder")
ss_meta <- sheets_get(ss)

df <- df %>% 
  mutate(
    sheet_orig = escape_brackets(sheet),
    sheet = map(sheet, parse_guess)
  ) %>% 
  select(x = range, everything())
df$sheet[df$sheet == "NULL"] <- list(NULL)
df <- df %>%
  mutate(range_spec = pmap(.,
    googlesheets4:::as_range_spec,
    sheets_df = ss_meta$sheets,
    nr_df     = ss_meta$named_ranges
  ))
```

```{r echo = FALSE}
df %>% 
  select(-sheet) %>% 
  rename(range = x, sheet = sheet_orig) %>% 
  mutate(range_spec = map_chr(range_spec, formatize)) %>% 
  knitr::kable()
```

## Reading

The reading functions `sheets_read()` and `sheets_cells()` hit the `sheets.spreadsheets.get` endpoint. Bizarrely, this endpoint requires the range to be specified in A1-notation. If the user specifies the cell rectangle in A1-notation, things are easy and we just use that. But users can describe certain partially open cell rectangles via `cell_limits` that can't be literally expressed in A1-notation. The table below shows how all possible combinations of row and cell limits are translated into an A1-style range, using technical limits on the number of rows and columns.

```{r echo = FALSE}
f <- function(start_col, start_row, end_col, end_row) {
  cellranger::cell_limits(
    ul = c(start_row, start_col), lr = c(end_row, end_col)
  )
}

g <- function(col) {
  ifelse(is.na(col), "?", cellranger::num_to_letter(col))
}

h <- function(row) ifelse(is.na(row), "?", row)

foo <- function(start_col2, start_row2, end_col2, end_row2, ...) {
  paste0(start_col2, start_row2, ":", end_col2, end_row2)
}

df <- crossing(
  start_col = c(NA, 2), start_row = c(NA, 2),
  end_col = c(NA, 4), end_row = c(NA, 4)
)

df <- df %>% 
  mutate(cell_limits = pmap(., f)) %>% 
  mutate(start_col2 = g(start_col), start_row2 = h(start_row)) %>% 
  mutate(end_col2 = g(end_col), end_row2 = h(end_row)) %>% 
  mutate(naive_range = pmap(., foo)) %>%
  mutate(range = map(cell_limits, googlesheets4:::as_sheets_range),
         range = map_chr(range, 1, .default = "&lt;NULL&gt;"))
```

```{r echo = FALSE}
knitr::kable(
  select(
    df,
    start_col, start_row, end_col, end_row,
    naive_range, range)
)
```
